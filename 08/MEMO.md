# 8日目

### harib05a
マウスの解説。  
まずマウスから0xfa(ACK)が返ってくるがキーコードには関係ないので読み飛ばして、mouse_dbufにキーコードを次々格納していく。値の詳細などは次。

### harib05b
コード整理。マウス用の構造体の追加。

### harib05c
マウスの状態を表示する。  
マウス移動や右クリック左クリック、ホイールボタンが押された時に表示を変える。
合計3バイトが保存されているが、この内最初の1バイトの値によって処理を変えている。おそらくx軸でマイナス方向に移動があれば最初の1バイトの上位4bitの0001が立ち、y軸でマイナス方向に移動があれば0010が立つ。このため0x10とxの論理積を取り、もしビットが立っていれば0xffffff00で論理和を取った値をxに代入している。負数のための処理？yも0x20と論理積を取り、以降はxと同様の処理を行っている。

### harib05d
マウスを動かす。  
前回の処理で取得したx,yを現在の座標に足しあわせて矢印を表示する。ただし現時点では既表示部分にカーソルを移動すると重なった部分が消える。

### harib05e
asmhead.nasの説明。  
最初の部分は割り込みを禁止するための処理。両方のPICのIMRに0xffを指定するような処理。  
次の部分はA20GATEをONにする処理。  
次に暫定的なGDTを設定し、CR0を設定する。CR0を適当なレジスタにMOVした後、bit31を0に(ページング禁止)し、bit0を1に(プロテクトモード以降)したレジスタをCR0に書き戻す。その後はパイプラインが崩れるためJMPしてすべて撤回する必要がある。この後はプロテクトモードに移行したためすべてのセグメントレジスタを変更する必要がある。1*8を代入しているのは0x0008がgdt+1のセグメントに相当するため。  
次はmemcpyを用いてbootpackとブートセクタ、それ以降のディスクイメージをメモリ上に転送する。ブートセクタは0x7c00に読み込むようORG命令を用いており、またセクタ2以降は0x0820以降に読み込むよう設定している(要参照ipl10.nas)。bootpackはasmhead.nasの一番下にラベルがあり、つまりリンカが繋ぐbootpack.hrbの最初のアドレスになる。  
その次はbootpackの起動になる。BOTPAKはbootpack.hrbを転送した先のアドレスになる。hrbのヘッダを確認した後にbootpack.hrbの0x10c8バイトから0x11a8バイトまでを0x00310000番地にコピーしている。色々と行っているが説明は後日。その後スタックの初期値をbootpack.hrbのヘッダの値から設定した後、セグメント2の0x1bにジャンプする。つまりbootpack.hrbを実行する。  
以降は関数の説明であったりGDT0(暫定GDT)の設定になる。GDT0はヌルセレクタと呼ばれ、セグメントの定義が行えない。GDT1と2はdsctbl.cのset_segmdescで出した値をそのままDWで書きだしている。GDTR0には16bitのlimit(3バイト-1？)と32bitの開始番地(GDT0のアドレス)が記載されている。  
ここまででasmhead.nasの処理は終了する。このためbootpack.cではまずGDTとIDTの初期設定を行う必要がある。初期化については既に先日扱ったとおり。

-----
* A20GATE…16bitモードでは1MB以上のメモリが扱えないように設計されているので、それを停止するための命令を送る信号線。
プロテクトモード…protected virtual address mode。保護された仮想メモリ番地を扱うモード。セグメントレジスタを16倍した値としてではなくGDTを使ってセグメント番号で仮想的にアドレスを扱うようになる。
リアルモード…real address mode。実メモリ番地を扱うモード。セグメントレジスタの値で直接アドレスを指定する。
* CR0…Control Register 0。OS以外が操作してはならない。
* ALIGNB…アライメントを行う？次に来るラベルの番地がオペランドの倍数になるまでDB 0を行う命令。
